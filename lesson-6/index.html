<!-- Array.forEach() -->

<!-- array.forEach(callback(currentValue, index, arr),thisValue)  -->

<!-- callback
Функция обратного вызова, которая будет выполнена один раз для каждого элемента в массиве. Функция принимает следующие параметры:
currentValue – значение текущего элемента.
index – индекс массива текущего элемента.
arr – массив, к которому принадлежит текущий элемент (по которому осуществляется проход). -->

<!-- Метод forEach() выполняет функцию callback один раз для каждого элемента, находящегося в массиве в порядке возрастания индекса. Функция callback не будет вызвана для удалённых или пропущенных элементов массива. Однако, она будет вызвана для элементов, которые присутствуют в массиве и имеют значение undefined. -->

<!-- <script>

    function ShowResults(value, index, ar) {
        document.write("значение: " + value);
        document.write(" индекс: " + index);
        document.write("<br />");
    }
    
    var letters = ['ab', 'cd', 'ef'];
    
    letters.forEach(ShowResults);
    
    //  значение: ab индекс: 0
    //  значение: cd индекс: 1
    //  значение: ef индекс: 2
    
</script> -->

<!-- Array.indexOf() -->

<!-- array.indexOf(searchElement, fromIndex) -->

<!-- searchElement-Искомый элемент в массиве. -->

<!-- fromIndex-Необязательный параметр. Позиция в массиве, с которой начинать поиск элемента searchElement.
Если значение параметра fromIndex больше или равно длине массива, возвращается -1.
Допускается использование отрицательных значений, в этом случае поиск производится начиная с индекса array.length + fromIndex по возрастанию. Если рассчитанный индекс оказывается меньше 0, поиск ведётся по всему массиву. Значение по умолчанию равно 0, что означает, что просматривается весь массив. -->

<!-- Индекс первого вхождения searchElement в массиве или -1, если searchElement не найден. -->

<!-- <script>

var arr = [1, 2, 3, "a", "b", "c"]; // инициализируем переменную, содержащую массив

alert(arr.indexOf( "a" ));     
alert(arr.indexOf( "d" ));    
alert(arr.indexOf( "b", 3 ));  
alert(arr.indexOf( 2, 2 ));   
alert(arr.indexOf( 1, -6 ));   
alert(arr.indexOf( 1, -5 ));   

</script> -->

<!-- <script>

var indexes = []; // инициализируем переменную, содержащую пустой массив
var array = ['a', 'b', 'a', 'c', 'a', 'd'];
var element = 'a';
var idx = array.indexOf(element); /* инициализируем переменную, содержащую
                                     индекс первого искомого элемента */
while (idx != -1) {
  indexes.push(idx);     /* с использованием метода push() добавляем в
                         переменную indexes значение переменной idx */
  idx = array.indexOf(element, idx + 1); /* изменяем значение переменной путем поиска
  необходимого элемента далее в массиве (если найден - индекс элемента, если нет то -1) */
}

document.writeln(indexes);
// [0, 2, 4]

</script> -->

<!-- Array.map() -->
<!-- array.map(function callback(currentValue, index, arr), thisValue) -->

<!-- Создаёт новый массив с результатом вызова указанной функции для каждого элемента массива. -->

<!-- searchElement -->

<!-- Функция обратного вызова, которая будет выполнена один раз для каждого элемента в массиве, принимает три аргумента:
currentValue – значение текущего элемента
index – индекс массива текущего элемента.
arr – массив, к которому принадлежит текущий элемент (по которому происходит проход). -->

<!-- Необязательный параметр. Объект, на который может ссылаться ключевое слово this внутри функции обратного вызова. Если параметр thisValue не используется, то в качестве значения this будет использоваться undefined (в конечном итоге, значение this, наблюдаемое из функции callback, определяется согласно обычным правилам определения this, видимого из функции). -->

<!-- Метод map() позволяет вызвать переданную функцию один раз для каждого элемента массива, формируя новый массив из результатов вызова этой функции.

Диапазон элементов, обрабатываемых с помощью метода map() устанавливается перед первым вызовом функции обратного вызова. Если элементы были добавлены к массиву после её вызова, то на таких элементах функция вызвана не будет.

Если существующие элементы массива изменяются функцией callback, их значения, переданные в функцию, будут значениями на тот момент времени, когда метод map() посетит их. Удалённые элементы посещены не будут. Если значения существующих элементов массива изменяются в момент выполнения, то в качестве передаваемого значения функции будет значение в тот момент времени, когда метод map() посещает их. Если элементы удаляются до их посещения, то такие элементы посещены не будут. -->
<!-- <script>

    var array = [10, 20, 30];
    
    var double = array.map( // вызываем переданную функцию один раз для каждого элемента массива, формируя новый массив
      function doubleNumber( currentValue ) {
        return currentValue * 2;
      }
    );
    
    alert( double ); // [20, 40, 60]
    
</script> -->

<!-- Array.filter() -->

<!-- array.filter(callback(currentValue, index, arr), thisValue); -->

<!-- callback
Функция обратного вызова, которая будет выполнена один раз для каждого элемента в массиве. Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется. Функция принимает следующие параметры:
currentValue – значение текущего элемента.
index – индекс массива текущего элемента.
arr – массив, к которому принадлежит текущий элемент (по которому происходит проход). -->
<!-- Возвращаемое значение -->
<!-- Новый массив, содержащий только те элемен ты массива, для которых функция обратного вызова вернет true. -->

<!-- Метод filter() создает новый массив и заполняет его элементами массива, для которых функция callback вернет true. Метод filter() не изменяет сам массив (хотя функция callback может делать это). Метод filter() выполняет цикл по индексам массива в порядке возрастания и вызывает callback для каждого элемента.
Если callback вернет true, элемент с индексом i в массиве будет добавлен во вновь созданный массив. После того как метод filter() проверит все элементы массива, он вернет новый массив. -->

<!-- <script>

    // определим функцию обратного вызова
    function getPrime(value, index, arr) {
        high = Math.floor(Math.sqrt(value)) + 1;
    
        for (var div = 2; div <= high; div++) {
            if (value % div == 0) {
                return false;
            }
        }
        return true;
    }
    
    var numbers = [3, 4, 5, 7, 8, 11, 13, 15, 17, 19, 21, 23, 27, 29, 31, 33, 37, 39, 41];
    
    // выберем простые числа из массива
    var primes = numbers.filter(getPrime);
    
    document.writeln(primes); // 3,5,7,11,13,17,19,23,29,31,37,41
     
</script> -->

<!-- <script>

var arr = [true, "js", NaN, "world", 7];

var result = arr.filter(
    function (value) {
        return (typeof value === 'string');
    }
);

document.writeln(result); // js, world
 
</script> -->

<!-- Map -->
<!-- Задача-1 -->
<!-- У вас есть массив строк, и вы хотите получить новый массив, содержащий длины каждой строки из исходного массива. -->

<!-- Задача-2 -->
<!-- У вас есть массив строк, и вы хотите получить новый массив, содержащий длины каждой строки из исходного массива. -->

<!-- Задача-3 -->
<!-- У вас есть массив строк, и вы хотите преобразовать каждую строку в верхний регистр и получить новый массив строк. -->

<!-- Задача-4 -->

<!-- У вас есть массив чисел, и вы хотите проверить каждое число в массиве на четность и получить новый массив из булевых значений, где true соответствует четному числу, а false - нечетному. -->

<!-- Задача-5 -->

<!-- У вас есть массив строк, и вы хотите получить новый массив объектов, где каждый объект содержит свойства name и length, соответствующие каждой строке в исходном массиве и длине этой строки. -->

<!-- Задача-6 -->
<!-- У вас есть массив объектов, и вы хотите получить новый массив, содержащий только одно свойство каждого объекта. -->

<!-- Задача-7 -->
<!-- У вас есть массив объектов, и вы хотите получить новый массив, содержащий объекты, в которых одно из свойств было преобразовано. -->

<!-- Задача-8 -->
<!-- У вас есть массив, и вы хотите создать новый массив с теми же элементами, но без изменения их значений. -->

<!-- Задача-9 -->
<!-- У вас есть массив, и вы хотите преобразовать его в строку, объединив все элементы массива через запятую. -->

<!-- Задача-10 -->
<!-- У вас есть массив, и вы хотите преобразовать каждый элемент массива на основе его индекса. -->

<!-- indexOf -->
<!-- Задача-1 -->
<!-- У вас есть массив, и вы хотите найти индекс первого вхождения элемента в массиве. -->

<!-- Задача-2 -->
<!-- У вас есть массив, и вы хотите проверить, содержится ли определенный элемент в массиве. -->

<!-- Задача-3 -->
 <!-- У вас есть строка, и вы хотите найти индекс первого вхождения подстроки в строку. -->

 <!-- Задача-4 -->

 <!-- У вас есть массив, и вы хотите найти индекс элемента, который соответствует определенному условию, используя функцию обратного вызова. -->

 <!-- Задача-5 -->
 <!-- У вас есть массив, и вы хотите найти все индексы элемента в массиве. -->

 <!-- Напишите функцию, которая принимает массив чисел и выводит на экран только те числа, которые больше 10. -->

 <!-- Создайте объект, который будет содержать информацию о разных курсах валют (название валюты, курс к доллару и т.д.). Используя функцию forEach, выведите на экран информацию о всех курсах валют. -->


 <!-- Напишите функцию, которая принимает массив чисел и умножает каждый элемент на 2. Результат сохраняется в том же массиве. -->

 <!-- Напишите функцию, которая принимает массив строк и выводит на экран только те строки, которые содержат букву "а". -->

 <!-- Создайте массив объектов, который будет содержать информацию о разных пользователях (имя, возраст, город и т.д.). Используя функцию forEach, выведите на экран информацию о всех пользователях, которые живут в городе "Москва". -->

 <!-- Из массива чисел отфильтруйте только положительные числа. -->

 <!-- Из массива строк отфильтруйте только те, которые начинаются с буквы "а". -->

 <!-- Из массива объектов пользователей отфильтруйте только тех, у кого возраст больше 30 лет. -->

 <!-- Из массива чисел отфильтруйте только нечетные числа. -->

 <!-- В JavaScript функции map и filter - это методы массивов, которые используются для преобразования и фильтрации элементов массива соответственно.

Функция map принимает функцию обратного вызова и возвращает новый массив, который состоит из результатов применения этой функции к каждому элементу исходного массива. Новый массив будет иметь ту же длину, что и исходный массив.
\\

<!-- Функция filter также принимает функцию обратного вызова, но возвращает новый массив, который содержит только те элементы исходного массива, для которых функция обратного вызова возвращает true. Новый массив может иметь меньшую длину, чем исходный массив. -->

